<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>uwu</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>

<script>
    let camera, scene, renderer;
    let terrainChunks = {};
    let simplex = new SimplexNoise();
    const chunkSize = 100;
    const maxHeight = 20;
    const preloadDistance = 500;

    init();
    animate();

    function init() {
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 50, 0);
        camera.rotation.x = -Math.PI / 6;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5, 10, 7.5);
        scene.add(light);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        window.addEventListener('resize', onWindowResize);
    }

    function generateChunk(xOffset, zOffset) {
        const geometry = new THREE.PlaneGeometry(chunkSize, chunkSize, 9, 9);
        geometry.rotateX(-Math.PI / 2);

        const vertices = geometry.attributes.position.array;
        const colors = [];
        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i] + xOffset;
            const z = vertices[i + 2] + zOffset;
            const height = simplex.noise2D(x / 100, z / 100) * maxHeight;
            vertices[i + 1] = height;

            const color = new THREE.Color();
            if (height < 2) {
                color.set(0x228B22)
            } else if (height < 5) {
                color.set(0x8B4513);
            } else {
                color.set(0xD3D3D3);
            }
            colors.push(color.r, color.g, color.b);
        }

        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        const material = new THREE.MeshStandardMaterial({ vertexColors: THREE.VertexColors });
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(xOffset, 0, zOffset);
        scene.add(mesh);

        return mesh;
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);

        const cameraSpeed = 0.5;
        camera.position.z -= cameraSpeed;

        const chunkX = Math.floor(camera.position.x / chunkSize);
        const chunkZ = Math.floor(camera.position.z / chunkSize);

        for (let x = chunkX - 3; x <= chunkX + 3; x++) {
            for (let z = chunkZ - 3; z <= chunkZ + 3; z++) {
                const key = `${x},${z}`;
                if (!terrainChunks[key]) {
                    terrainChunks[key] = generateChunk(x * chunkSize, z * chunkSize);
                }
            }
        }

        Object.keys(terrainChunks).forEach(key => {
            const [x, z] = key.split(',').map(Number);
            const distance = Math.sqrt(
                Math.pow(x * chunkSize - camera.position.x, 2) +
                Math.pow(z * chunkSize - camera.position.z, 2)
            );
            if (distance > preloadDistance) {
                scene.remove(terrainChunks[key]);
                delete terrainChunks[key];
            }
        });

        renderer.render(scene, camera);
    }
</script>
</body>
</html>

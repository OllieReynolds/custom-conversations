<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>uwu</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        .scrolling-text-container {
            position: fixed;
            top: 40%;
            left: 50%;
            transform: translateX(-50%);
            overflow: hidden;
            white-space: nowrap;
            z-index: 999;
        }
        .scrolling-text {
            display: inline-block;
            color: white;
            font-size: 48px;
            font-weight: bold;
            font-family: Arial, sans-serif;
            animation: scroll 40s linear infinite;
        }
        @keyframes scroll {
            0% {
                transform: translateX(100%);
            }
            100% {
                transform: translateX(-200%);
            }
        }
        .arg-text {
            position: absolute;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 72px;
            font-weight: bold;
            text-align: center;
            z-index: 999;
        }
    </style>
</head>
<body>
    <div class="scrolling-text-container">
        <div class="scrolling-text">
            <p><strong>1:  </strong>Vspcly Ylfuvskz ohz klltlk fvb dvyaof</p>
            <p><strong>2:  </strong>Blf szev rnkivhhvw nv!</p>
            <p><strong>3:  </strong>Id nneube. inttikayn ol ohr.d'h owdt.</p>
            <p><strong>4:  </strong>Afsg imzuvpkxziptc xl ilozpputm.</p>
            <p><strong>5:  </strong>01010111011001010110110001101100001000000110010001101111011011100110010100100001</p>
        </div>
    </div>
    
    <div class="arg-text">
        <p>Ollie's ARG - Â£25 for winner, paid next month (decode all ciphers)</p>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@2.4.0/simplex-noise.min.js"></script>

    <script>
        let camera, scene, renderer;
        let terrainChunks = {};
        let simplex = new SimplexNoise();
        const chunkSize = 500;
        const maxHeight = 30;
        const preloadDistance = 3500;
        const segments = 100;

        init();
        animate();

        function init() {
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 0);
            camera.rotation.x = -Math.PI / 6;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);


            const fogColor = 0x87CEEB;
            const near = 10;
            const far = 600;
            scene.fog = new THREE.Fog(fogColor, near, far);

            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(5, 10, 7.5);
            scene.add(light);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            window.addEventListener('resize', onWindowResize);
        }

        function generateChunk(xOffset, zOffset) {
            const geometry = new THREE.PlaneGeometry(chunkSize, chunkSize, segments, segments);
            geometry.rotateX(-Math.PI / 2);

            const vertices = geometry.attributes.position.array;
            const colors = [];
            for (let i = 0; i < vertices.length; i += 3) {
                const x = vertices[i] + xOffset;
                const z = vertices[i + 2] + zOffset;
                const height = simplex.noise2D(x / 100, z / 100) * maxHeight;
                vertices[i + 1] = height;

                const color = getColor(height);
                colors.push(color.r, color.g, color.b);
            }

            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const material = new THREE.MeshStandardMaterial({ vertexColors: THREE.VertexColors });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(xOffset, 0, zOffset);
            scene.add(mesh);

            return mesh;
        }

        function getColor(height) {
            if (height < 5) {
                return new THREE.Color(0x87CEEB);
            } else if (height < 10) {
                return new THREE.Color(0x228B22);
            } else if (height < 20) {
                return new THREE.Color(0x8B4513);
            } else {
                return new THREE.Color(0xFFFFFF);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            const cameraSpeed = 0.5;
            camera.position.z -= cameraSpeed;

            const chunkX = Math.floor(camera.position.x / chunkSize);
            const chunkZ = Math.floor(camera.position.z / chunkSize);

            for (let x = chunkX - 3; x <= chunkX + 3; x++) {
                for (let z = chunkZ - 3; z <= chunkZ + 3; z++) {
                    const key = `${x},${z}`;
                    if (!terrainChunks[key]) {
                        terrainChunks[key] = generateChunk(x * chunkSize, z * chunkSize);
                    }
                }
            }

            Object.keys(terrainChunks).forEach(key => {
                const [x, z] = key.split(',').map(Number);
                const distance = Math.sqrt(
                    Math.pow(x * chunkSize - camera.position.x, 2) +
                    Math.pow(z * chunkSize - camera.position.z, 2)
                );
                if (distance > preloadDistance) {
                    scene.remove(terrainChunks[key]);
                    delete terrainChunks[key];
                }
            });

            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
